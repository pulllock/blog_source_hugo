---
title: Java基础之HashMap简介
date: 2016-05-25 15:47:13
categories: Java基础
---

HashMap就是数据结构中的散列表，可以先学习数据结构中的散列表，再看HashMap的实现。

<!--more-->

# 散列和散列表

数据结构中的散列（Hash）是一种按照关键字编址的存储和查找技术。

散列表（Hash Table）根据元素关键字确定元素的存储位置 ，查找、插入、删除效率接近O(1)。

散列表存储元素冲突的解决办法有：开放定址法和链地址法。

开放定址法：当产生冲突时，在散列表中寻找另外一个位置存储冲突元素，寻找位置的方法有线性探查法和二次探查法。

线性探查法：如果检测到冲突，则向后继续查找，直到找到一个空位置。这种线性探查法解决冲突时，可能会占用其他元素位置；查找可能退化成顺序查找；不能删除元素，否则探测序列会被中断。

链地址法：在遇到冲突时，会将冲突元素组成一个链表。

# HashMap

基于JDK1.8。

散列映射（HashMap）是使用散列表存储元素实现的映射。内部使用一个数组来存放元素，不过数组中不是存放的元素本身，而是一个结点Node。HashMap这是用链地址法来解决冲突，当冲突发生的时候，会将冲突元素结点组成一个链表。

JDK1.8版本的HashMap在冲突链表达到一定长度的时候，将链表转化为一颗红黑树，用来提高查找效率。红黑树中结点是TreeNode。当移除元素后，如果元素个数减少到一定程度，就会将红黑树重新转换成链表。

HashMap不是一个线程安全的类，多线程操作可能会出现结点和值的丢失。在并发中请使用ConcurrentHashMap类。

## 扩容

JDK1.7中扩容的原理如下：

1. 新建一个数组，长度为原来的两倍。
2. 遍历原来数组每一个元素，重新计算新的索引位置放到新数组中去。

JDK1.8中扩容原理和JDK1.7类似，但是计算元素的位置的方法不一样，JDK1.7需要重新计算每个key在新数组中的哈希值，1.8则使用了另外的方式，不需要计算哈希值。

## 树化

当链表的长度大于等于阈值的时候，将链表转化为红黑树。也不是所有情况下都会转为红黑树。当HashMap中的桶个数比较小的时候，不会先树化，而是先扩容，当桶的数量大于等于一个阈值的时候，才会进行树化。

当桶比较小的时候，冲突率很高，这时候可以先选择将桶扩容，而不是先进行树化。冲突产生的原因是因为桶的容量小，所以解决冲突的最好办法就是扩容。另外桶比较小的时候，扩容会比较频繁，如果桶比较小的时候就进行冲突链转为树，一旦遇到频繁扩容，就会导致红黑树的频繁拆分。

在树化的时候，HashMap使用next和prev保留了原来链表的节点顺序。

## 红黑树的链化

在树化的时候，HashMap使用next和prev保留了原来链表的节点顺序。链化的时候，就直接将TreeNode转成Node就可以。

# 源码

参照源码解析：[https://github.com/dachengxi/Java8u192SourceCode](https://github.com/dachengxi/Java8u192SourceCode)


# 参考
- 《数据结构（Java版）》