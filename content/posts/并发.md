---
title: "并发"
date: 2023-10-25T14:35:20+08:00
---

# 并发定义（《深入理解计算机系统》）

> 如果逻辑控制流在时间上重叠，那么它们就是并发的（concurrent）。这种常见的现象称为并发（concurrency），出现在计算机系统的许多不同层面上。

# 进程间的关系（《操作系统原理》）

进程之间的两种基本关系：

- 竞争关系
- 协作关系

竞争关系会出现两个问题：

- 死锁（deadlock）
- 饥饿（starvation）

解决进程间竞争关系的手段：

- 互斥（mutual exclusion）

解决进程间协作关系的手段：

- 同步（synchronization）

进程互斥关系是一种特殊的进程同步关系。

# 互斥（《操作系统原理》）

- 临界区（critical section）：并发进程中与共享变量有关的程序段
- 临界资源（critical resource）：共享变量代表的资源

实现临界区管理的方法：

- 软件方法
- 硬件方法
- 信号量
- 管程
- 消息传递

实现临界区管理的软件方法：

- Dekker算法，只适用于两个进程，多个进程实现很复杂
- Peterson算法，容易适用于多个进程

实现临界区管理的硬件方法：

- 关中断，能保证锁测试和上锁操作的连续性和完整性，不适用于多CPU系统
- Test and Set指令
- Swap指令

# 同步（《操作系统原理》）

操作系统实现进程同步的机制称为同步机制，通常由同步原语组成。常用的同步机制：

- 信号量及PV操作
- 管程
- 消息传递

## 信号量（semaphore）

在操作系统中，信号量用于表示物理资源的实体，它是一个与队列有关的整形变量。除赋值以外，信号量仅能由同步原语对其进行操作，信号量操作源于：

- P操作（测试）
- V操作（增量）

信号量按照用途可以分为两种：

- 公用信号量：联系一组并发进程，相关的进程均可在此信号量上执行P和V操作。初值常常为1，用于实现进程互斥。
- 私有信号量：联系一组并发进程，仅允许此信号量拥有的进程执行P操作，而其他相关进程可在其上施行V操作。初值常常为0或正整数，多用于并发进程同步。

信号量按照取值可分为两种：

- 二元信号量：仅允许取值为0和1，主要用于解决互斥问题
- 一般信号量：允许取值为非负整数，主要用于解决进程同步问题

### 整型信号量

设s为一个整型变量，除了初始化外，仅能通过P、V操作来访问它。P操作原语和V操作原语定义如下：

- P(s)：当信号量s大于0时，把信号量减去1，否则调用P(s)的进程等待直到信号量s大于0
- V(s)：把信号量s加1

整型信号量在P操作不满足条件的时候会进行忙等待。

### 记录型信号量

设s为一个记录型数据结构，一个分量为整型量value，value通常是非负数；另一个分量为信号量队列queue，queue是一个初始化状态为空的进程队列。P操作原语和V操作原语定义如下：

- P(s)：将信号量s减去1，若结果小于0，则调用P(s)的进程被设置成等待信号量s的状态
- V(s)：将信号量加1，如果结果不大于0，则释放一个等待信号量s的进程

### 二元信号量

设s为一个记录型数据结构，一个分量为value，value取值为0或1；另一个分量为信号量队列queue。

## 管程

使用信号量和P、V操作实现同步时，对共享资源的管理分散在各个进程中，进程能直接对共享变量进行处理，不利于系统对临界资源的管理，难以防止进程有意或无意的违法同步操作，容易造成程序设计错误。

管程（monitor）：
- 管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块
- 管程提供了一种互斥机制，进程可以互斥的调用这些过程
- 管程把分散在各个进程中互斥的访问公共变量的那些临界区集中起来，提供对它们的保护

条件变量（condition variables）：进程在资源不能满足而无法继续运行时被阻塞在某些条件变量上。

进程P执行了signal操作后，条件变量队列中有一个在等待的进程Q被释放，这是就有两个进程在管程中同时运行，可对它们做如下处理：

- 进程P等待，直到进程Q退出管程或者进程Q等待另外一个条件
- 进程Q等待，直到进程P退出管程或者进程P等待另外一个条件

- 霍尔管程采用第一种：进程P等待，直到进程Q退出管程或者进程Q等待另外一个条件
- 汉森管程采用两者折中的方式：规定管程中的过程所执行的signal操作是过程体的最后一个操作，于是进程P执行signal操作后立即退出管程，因此进程Q立刻被恢复执行
- MESA管程采用第二种：进程Q等待，直到进程P退出管程或者进程P等待另外一个条件

# Dekker算法

如果两个进程尝试同时进入同一个临界区，Dekker算法只允许其中一个进程能够成功进入临界区。如果一个进程已经进入了临界区，另外一个进程会进行忙等待，一直等到进入临界区的进程退出临界区。算法需要两个共享变量来控制：
- 一个大小为2的boolean类型数组变量：`boolean[] wants_to_enter = {false, false}`，表示进程想要进入临界区，比如`wants_to_enter[0] = true`表示进程0想要进入临界区
- 一个int类型的变量：`int turn = 0`：表示哪个进程现在能够进入临界区，比如`turn = 0`表示进程0可以进入临界区，`turn = 1`表示进程1可以进入临界区，该变量的值只能是0或1

Dekker算法的伪代码如下：

```c
// 变量声明
// 该变量表示进程想要进入临界区
boolean[] wants_to_enter = {false, false};

// 该变量表示哪个进程能够进入临界区，值只能是0或者1
int turn = 0;
```

```c
// 进程0
void process0() {
    while (true) {
        // 首先声明当前进程0想要进入临界区
        wants_to_enter[0] = true;

        // 查看进程1是不是也同时声明了想要进入临界区，
        // 如果进程1也想要进入临界区，那当前进程0会先尝试把机会让给进程1
        while (wants_to_enter[1]) {
            // 如果进程1此时能够进入临界区
            if (turn == 1) {
                // 进程1已经获得了进入临界区的优先权，所以当前进程0收回自己想要进入临界区的想法
                wants_to_enter[0]= false;

                // 当前进程0会在这里一直忙等待，等待进程1退出临界区，进程1退出临界区后，
                // 就会把turn改为0，也就是把进入临界区的优先权让给进程0，并且进程1也会声明自己
                // 不再想要进入进入临界区：wants_to_enter[1] = false
                while (turn == 1) {

                }

                // 到这里说明进程1已经退出临界区，进程1把进入临界区的优先权给了进程0，
                // 此时进程0可以再次声明想要进入临界区
                wants_to_enter[0] = true;
            }
        }

        // 当前进程0执行临界区的代码
        do_something_in_critical_section();

        // 当前进程0执行完临界区代码后，将进入临界区的优先权给进程1
        // 同时设置当前进程0不再想要进入临界区
        turn = 1;
        wants_to_enter[0] = false;
    }
}
```

```c
// 进程1
void process1() {
    while (true) {
        // 首先声明当前进程1想要进入临界区
        want_to_enter[1] = true;

        // 查询进程0是不是也同时想要进入临界区
        // 如果进程0也想要进入临界区，当前进程1会先尝试把机会让给进程0
        while (want_to_enter[0]) {
            // 如果此时进程0能够进入临界区
            if (turn == 0) {
                // 进程0已经获得了进入临界区的优先权，所以当前进程1收回自己想要进入临界区的想法
                wants_to_enter[1] = false;

                // 当前进程1会在这里一直忙等待，等待进程0退出临界区，进程0退出临界区后，
                // 就会把turn改为1，也就是把进入临界区的优先权让给进程1，并且进程0也会声明自己
                // 不再想要进入进入临界区：wants_to_enter[0] = false
                while (turn == 0) {

                }

                // 到这里说明进程0已经退出临界区，进程0把进入临界区的优先权让给了进程1，
                // 此时进程1可以再次声明想要进入临界区
                wants_to_enter[1] = true;
            }
        }

        // 当前进程1执行临界区的代码
        do_something_in_critical_section();

        // 当前进程1执行完临界区代码后，将进入临界区的优先权给进程0
        // 同时设置当前进程1不再想要进入临界区
        turn = 0;
        wants_to_enter[1] = false;
    }
}
```

# Peterson算法

算法需要使用两个共享变量来控制：

- 一个大小为2的boolean类型数组变量：`boolean[] wants_to_enter = {false, false}`，表示进程想要进入临界区，比如`wants_to_enter[0] = true`表示进程0想要进入临界区
- 一个int类型的变量：`int turn = 0`：表示哪个进程现在能够进入临界区，比如`turn = 0`表示进程0可以进入临界区，`turn = 1`表示进程1可以进入临界区，该变量的值只能是0或1

Peterson算法的伪代码如下：

```c
// 变量声明
// 该变量表示进程想要进入临界区
boolean[] wants_to_enter = {false, false};

// 该变量表示哪个进程能够进入临界区，值只能是0或者1
int turn = 0;
```

```c
void process0() {
    // 当前进程0声明自己想要进入临界区
    wants_to_enter[0] = true;
    // 先将进入临界区的优先权让给进程1
    turn = 1;
    // 判断如果进程1也想要进入临界区，并且进程1也有进入临界区的优先权
    while (wants_to_enter[1] && turn == 1) {
        // 当前进程0需要忙等待，等待进程1从临界区退出
    }
    // 当前进程0进入临界区
    do_something_in_critical_section();
    // 当前进程0退出临界区后，声明自己不想要进入临界区
    wants_to_enter[0] = false;
}
```

```c
void process1() {
    // 当前进程1声明自己想要进入临界区
    wants_to_enter[1] = true;
    // 先将进入临界区的优先权让给进程0
    turn = 0;
    // 判断如果进程0也想要进入临界区，并且进程0也有进入临界区的优先权
    while (wants_to_enter[0] && turn == 0) {
        // 当前进程1需要忙等待，等待进程0从临界区退出
    }
    // 当前进程1进入临界区
    do_something_in_critical_section();
    // 当前进程1退出临界区后，声明自己不想要进入临界区
    wants_to_enter[1] = false;
}
```

# 进程间通信（《现代操作系统》）

进程间通信的三个问题：

- 进程如何把信息传递给另一个
- 确保两个或更多进程在关键活动中不会出现交叉
- 正确的顺序

实现互斥的方案：

- 屏蔽中断：是硬件方法，屏蔽中断不适合交给用户进程，不适用于多处理器
- 锁变量：是软件方法，对共享锁本身的修改会发生竞态条件
- 严格轮转算法：是软件方法，要求两个进程严格的轮流进入它们的临界区
- Dekker算法：是软件方法
- Peterson算法：是软件方法
- TSL指令：需要硬件支持锁住内存总线，TSL称为测试并添加（test and set lock）
- XCHG指令：需要硬件支持

Peterson解法和TSL或XCHG解法都是正确的，但它们都有忙等待的缺点，忙等待会浪费CPU时间，可能会产生优先级反转问题（priority inversion problem）。

- 信号量：
  - 二元信号量
- 互斥量：是一个可以处于两态之一的变量
- 管程（monitor）：管程是一个由过程、变量及数据结构等组成的一个集合
- 消息传递
- 屏障（barrier）
- 避免锁：读-复制-更新

# 并发（《操作系统导论》）

- 控制中断：只适合单处理器
- 测试并设置指令（原子交换）
- 比较并交换
- 链接的加载和条件式存储指令
- 获取并增加

# 进程同步（《操作系统概念》）

- 竞态条件（race condition）：多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关，称为竞态条件
- 信号量
  - 计数信号量：值域不受限制
  - 二进制信号量：值只能为0或1
- 管程