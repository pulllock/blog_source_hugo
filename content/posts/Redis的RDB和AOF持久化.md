---
title: Redis的RDB和AOF持久化
date: 2019-04-02 20:01:00
categories: 
- Redis
---

Redis可以将内存中的数据库状态持久化到磁盘中去，提供了两种持久化方法：RDB持久化和AOF持久化。

<!--more-->

# RDB持久化

RDB持久化功能既可以手动执行，也可以根据服务器配置定期执行，会将某个时间点上的数据库状态保存到一个RDB文件中。

## RDB创建和加载

RDB文件创建有两个命令：SAVE和BGSAVE

- SAVE，会阻塞Redis服务进程，直到RDB文件创建完毕，此期间服务器不能处理任何命令请求。
- BGSAVE，会派生一个子进程去创建RDB文件，服务器进程继续处理命令请求。

RDB文件恢复是在服务器启动的时候自动执行的，只要Redis服务器启动时检测到RDB文件存在，就自动载入RDB文件，RDB载入期间，服务器会一直处于阻塞，直到载入完成才能提供服务。

- 如果开启了AOF，则优先使用AOF来还原数据库状态，因为AOF文件更新频率比RDB文件更新频率高。
- 如果AOF未开启，则使用RDB来还原数据库状态。

另外，SAVE、BGSAVE、BGREWRITEAOF三个命令之间也会有一些互斥的关系：

- SAVE命令执行期间，Redis服务器会被阻塞，所有客户端的请求都会被拒绝。
- BGSAVE是子进程，在执行期间，SAVE命令会被拒绝，新的BGSAVE命令也会被拒绝。
- BGSAVE运行期间，BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕。
- BGREWRITEAOF执行期间，BGSAVE命令会被拒绝。

## RDB自动保存的时机

Redis允许配置save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。配置的保存选项可以有多个，只要其中任一个条件满足，服务器就会执行BGSAVE命令。

配置的选项存在redisServer结构的saveparams属性中，saveparams是一个数组，每一项是一个saveparam结构，表示一个配置的保存选项。

```c
struct redisServer {
    // ...
    // saveparams数组
    struct saveparam *saveparams;
    // ...
    // 修改计数器
    long long dirty;
    // 上一次执行保存的时间
    time_t lastsave;
};

struct saveparam {
    // 秒数
    time_t seconds;
    // 修改次数
    int changes;
}
```



### dirty计数器和lastsave属性

redisServer结构中还有一个dirty计数器和leastsave属性：

```c
redisServer {
  // 计数器，记录距离上一次成功执行SAVE或者BGSAVE命令后，服务器对数据库进行了多少次修改
  long long dirty;
  
  // 上一次执行SAVE命令或者BGSAVE命令的时间
  time_t lastsave;
}
```

Redis的时间事件serverCron默认每隔100ms执行一次，其中就会检查保存选项是否满足，如果条件满足了，就会执行BGSAVE命令。

## RDB文件结构

结构可参考书上内容，暂不写。

# AOF持久化

AOF（Append Only File），通过保存Redis服务器所执行的写命令来记录数据库状态，而RDB是保存数据库中的键值对数据来记录数据库状态。

## AOF持久化实现

AOF持久化功能实现分为三部分：

- 命令追加append，执行完一个写命令后，会以协议格式将写命令追加到服务器的aof_buff缓冲区末尾。
- 文件写入（还在内存中）
- 文件同步sync到磁盘上

文件写入和同步有三个选项appendfsync：

- always，每个事件都要将aof_buf缓冲区中所有内容写入到AOF文件中，并且同步AOF文件，效率最慢，但是最安全，出现故障只会丢失一个事件循环中的命令数据。
- everysec，每个事件循环都要将aof_buf缓冲区所有内容写到AOF文件，并且每隔一秒就要在子线程中对AOF进行同步一次，效率足够快，出现故障会丢失1秒的数据。默认选项是这个。
- no，每个事件循环都要将aof_buf缓冲区内容写到AOF文件中，但AOF文件同步则由操作系统决定，由于不进行同步操作，效率最好，但是出现故障丢失的数据是积累一段时间的数据。

从内存到磁盘的持久化有三种方式：

- sync，只是将修改过的内存块缓冲区加入写队列，就返回，不等待实际的IO操作结束。性能好，但是掉电有丢失数据的风险。
- fsync，强制将修改过的数据同步到磁盘上，等待磁盘操作结束才返回，并且刷新文件的所有信息。性能差，但是不会丢失数据。
- fdatasync，强制将修改过的数据同步到磁盘上，但是不修改文件本身的一些元数据（比如修改时间、访问时间；如果文件大小变了需要刷新元数据），可以减少IO次数。性能比fsync好，可能会丢失一些元数据的风险。

## AOF文件载入和数据还原

服务器读取并重新执行一遍AOF文件中保存的写命令：

1. 创建一个不带网络连接的伪客户端
2. 从AOF文件中分析读取一条写命令
3. 使用伪客户端执行被读出的写命令

## AOF重写

AOF重写就是让原来的AOF文件变小，去除冗余的命令。

AOF持久化记录了被执行的写命令，AOF文件会越来越大，会对服务器造成影响，恢复时间也会很长，AOF采用重写rewrite来解决文件膨胀问题，创建一个新的AOF文件代替现有的AOF文件，新旧文件保存的数据库状态相同，但是新文件不会包含冗余的命令，体积会比旧文件小很多。

重写不是读取原来AOF文件进行重写，而是读取服务器当前的数据库状态进行实现，简单说就是根据数据库现有状态，将现有一个键值对的数据汇总成一条写命令，而不是原来的若干条命令。这样就减少了AOF文件的大小。

## AOF后台重写

由于AOF重写会阻塞服务，所以需要采用后台重写，后台重写使用子进程来处理。子进程开始重写文件后，主进程还在继续提供服务，会有新的命令进来，会造成重写后的AOF文件和数据库状态不一致，Redis使用AOF重写缓冲区来解决，Redis服务器执行一个写命令后，会同时将这个命令发送给AOF缓冲区和AOF重写缓冲区。

子进程完成AOF重写工作后，会向父进程发一个信号，父进程会调用处理函数：

1. 将AOF重写缓冲区所有内容写到新的AOF文件中，新的AOF文件和服务器当前数据库状态就保持一致了。
2. 对新AOF文件改名，并原子的覆盖现有AOF文件，完成新旧文件的替换。

## 几个特殊命令的写AOF操作

通常情况下Redis只会将那些对数据库进行修改的命令写入到AOF文件中，并复制到各个从服务器，但是PUBSUB命令和SCRIPT LOAD命令是例外：

- PUBSUB没有修改数据库，但是PUBSUB命令向频道所有订阅者发送消息这一行为带有副作用，接受到消息的所有客户端状态会改变，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，将来载入AOF文件时，服务器可以再次执行相同的PUBSUB命令。
- SCRIPT LOAD命令没有修改数据库，但是修改了服务器状态，也是一个带有副作用的命令，服务器使用REDIS_FORCE_AOF强制将这个命令写入AOF文件。

# RDB和AOF对比

- RDB持久化是保存数据库中键值对来记录数据库状态的不同
- AOF持久化是通过保存服务器执行的写命令来记录数据库状态
- RDB文件紧凑，全量备份，适合用于备份和灾难恢复，在恢复大数据集时的速度比AOF快
- RDB持久化期间修改的数据可能会丢失

# BGSAVE和BGREWRITEAOF对哈希表rehash的影响

如果没有BGSAVE和BGREWRITEAOF执行的时候，哈希表负载因子大于等于1的时候，进行rehash，而当有BGSAVE和BGREWRITEAOF执行的时候，哈希表负载因子会提高，当大于等与5的时候才会进行rehash。

这是因为执行BGSAVE和BGREWRITEAOF的时候，是需要创建子进程来执行的，而大多数操作系统采用写时复制（Copy on Write）来优化子进程的效率，服务器提高负载因子后，就可以减少在有子进程存在期间哈希表的扩展操作，可以减少内存的写入操作，节约内存。

# 参考

- 《redis设计与实现》（第二版）