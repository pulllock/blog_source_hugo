---
title: Redis客户端和服务器简介
date: 2019-04-02 22:01:00
categories: 
- Redis
---

Redis客户端和服务器实现的学习。

<!--more-->

# Redis客户端

每一个和服务器连接的客户端，都有一个client结构与之对应，并且这些client组成一个链表，保存在redisServer的clients属性中。

客户端client结构如下：

```c
typedef struct client {
    // 客户端套接字描述符
    int fd;
    /**
     * db记录了客户端当前的目标数据库
     * 是指向redisDb结构的指针
     */
    redisDb *db; 
    // 客户端名字
    robj *name;
    // 客户端创建时间
    time_t ctime;
    // 客户端标志，比如是主还是从
    int flags;
    // ...
} client;
```

```c
struct redisServer {
    // ...
    // clients是一个链表，保存了所有的客户端
    list *clients;
    // ...
};
```

## 普通客户端和伪客户端

redis的客户端有两种：

- 伪客户端，套接字描述符是-1，主要是在AOF文件载入时执行AOF文件中包含的redis命令以及执行lua脚本中包含的redis命令的
- 普通客户端，套接字描述符大于-1的整数，处理来自网络的请求

### 普通客户端

客户端通过connect函数连接到服务器，服务器调用连接事件处理器，为客户端创建相应的客户端状态，并将这个客户端加入到服务器状态redisServer的clients链表的末尾

### lua脚本的伪客户端

服务器初始化的时候会创建一个负责执行lua脚本中包含的redis命令的伪客户端，并将这个伪客户端关联到服务器状态redisServer的lua_client属性中。lua_client在服务器运行的整个生命周期一直存在，只有在服务器被关闭，这个客户端才会被关闭

### AOF文件的伪客户端

服务器在载入AOF文件的时候会创建用于执行AOF文件中包含的redis命令的伪客户端，并在载入文件完成后关闭这个伪客户端

# Redis服务器

redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求。

## 命令请求的执行过程

1. 客户端发送命令请求
2. 服务端读取命令请求
3. 命令执行器查找命令实现
4. 命令执行器执行预备操作
5. 命令执行器调用命令的实现函数
6. 命令执行器执行后续工作
7. 将命令回复发送给客户端
8. 客户端接收并打印命令回复

### 客户端发送命令请求

客户端会将命令请求转换成redis的协议格式，连接到服务器套接字，并将命令请求发送到服务器。

### 服务端读取命令请求

客户端发送命令到服务端，服务器调用命令请求处理器readQueryFromClient来进行命令请求的读取，主要有以下步骤：

1. 从套接字中读取redis协议格式的命令请求，并保存到客户端状态client的输入缓冲区querybuf中。
2. 对输入缓冲区中的命令请求进行解析，提取出命令参数和命令参数个数，保存在argv和argc属性中。
3. 调用命令执行器，执行客户端发送的命令。

### 查找命令请求

Redis中命令和命令的实现保存在一个字典中，称为命令表，字典的key是redis命令，字典的value是命令对应的实现redisCommand结构。

可以根据从输入缓冲区中解析到的argv[0]里面的命令到命令表中查找对应命令的实现，然后执行命令。

### 执行预备操作

在从命令表中找到命令对应的命令实现后，还需要执行一些预备工作，才会真正执行命令：

- 命令是否存在
- 命令所需要参数个数是否正确
- 检查客户端是否通过了身份验证
- 如果启用了maxmemmory配置，执行命令前需要先检查服务器内存占用情况，并在需要的时候进行内存回收
- 如果上一次执行BGSAVE失败，并且服务器打开了是投票-writes-on-bgsave-error，并且此时要执行的是写命令，则服务器拒绝执行该命令
- 如果客户端正在使用SUBSCRIBE命令订阅频道，或者正再用PSUBSCRIBE命令订阅模式，则服务器只会执行SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他的命令都会被服务器拒绝
- 如果服务器正在进行数据载入，客户端发送的命令必须带有l标识，比如INFO、SHUTDOWN、PUBLISH等命令才会被服务器执行，其他的都会被服务器拒绝
- 如果服务器因执行lua脚本而超时并进入阻塞状态，则服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被拒绝
- 如果客户端正在执行事务，服务器只会执行客户端发送的EXEC、DISCARD、MULTI、WATCH命令，其他命令都会被放进事务队列中
- 如果服务器打开监视器功能，服务器要执行的命令和参数信息会发送给监视器。

### 调用命令实现函数

在argv[0]中保存了命令，argv其他的位置保存的是命令所需要的参数。在命令实现函数执行完后，会产生相应的命令回复，命令回复会保存在客户端状态client的输出缓冲区中（buf和reply属性），然后命令实现函数会为客户端套接字关联命令回复处理器sendReplayToClient。

### 执行后续工作

执行完命令实现函数后，服务器还要做一些后续工作：

- 如果开启慢查询日志功能，则根据情况记录慢查询日志
- 更新redisCommand结构的一些属性：milliseconds命令耗费时长、calls计数器加1
- 如果开启了AOF持久化功能，则将刚执行的命令请求写入到AOF缓冲区
- 如果有其他服务器正在复制当前服务器，则服务器将刚刚执行的命令传播给所有从服务器

### 将命令回复发送给客户端

命令函数执行后会将命令回复保存到客户端状态的输出缓冲区，并为客户端套接字关联命令回复处理器sendReplayToClient。

当客户端套接字变的可写时，服务器就执行命令回复处理器，并将输出缓冲区中的命令回复发送给客户端。命令回复发送完后，命令回复处理器会清空客户端状态的输出缓冲区

### 客户端接收并打印命令回复

客户端接受到redis协议格式的命令回复后，会打印出来。

# 参考

- 《redis设计与实现》（第二版）